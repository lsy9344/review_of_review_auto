# 쿠키를 이용한 로그인 유지 및 관리 방법

이 문서는 `original_source/lambda_function.py` 스크립트에서 네이버 로그인을 처리할 때 쿠키를 어떻게 저장하고 재사용하는지에 대해 설명합니다. 쿠키를 활용하여 매번 아이디와 비밀번호로 로그인하는 것을 방지하고, 세션을 유지하여 안정적으로 자동화 스크립트를 실행하는 것이 목적입니다.

## 1. 쿠키 저장 과정

로그인에 성공하면, 스크립트는 현재 세션의 쿠키를 수집하여 데이터베이스에 저장합니다. 이 과정은 다음 단계로 이루어집니다.

### 가. 최초 로그인 및 쿠키 생성

1.  **쿠키 부재 시 로그인 시도**: `login` 함수는 `cookies` 파라미터가 `None`일 경우, 즉 데이터베이스에 저장된 쿠키가 없을 때, 셀레니움을 통해 직접 아이디와 비밀번호를 입력하여 로그인을 시도합니다.

    ```python
    def login(cookies):
        print('로그인')
        if not cookies:
            print("쿠키 없음, 로그인 진행")
            # ... (ID/PW 입력 및 로그인 로직) ...
    ```

2.  **쿠키 추출**: 로그인에 성공하면 `WebDriverWait`를 통해 페이지 URL이 `naver.com`을 포함할 때까지 대기한 후, `driver.get_cookies()`를 호출하여 현재 브라우저 세션의 모든 쿠키를 가져옵니다.

    ```python
    # ... 로그인 성공 후 ...
    WebDriverWait(driver, 10).until(
        EC.url_contains('naver.com')
    )

    cookies = driver.get_cookies()
    ```

3.  **데이터베이스에 저장**: 추출된 쿠키 목록은 `json.dumps`를 사용하여 JSON 문자열로 변환된 후, `session_upsert_db` 함수를 통해 DynamoDB 테이블(`session`)에 저장됩니다.

    ```python
    session_upsert_db(json.dumps(cookies))
    ```

    ```python
    def session_upsert_db(value):
        response = session_table.put_item(Item={
            'id': '1',
            'cookies': value
        }
        )
        # ...
    ```

## 2. 저장된 쿠키 가져오기 및 사용

스크립트가 실행될 때마다, 우선 데이터베이스에 저장된 쿠키를 가져와 로그인을 시도합니다.

### 가. 쿠키 로드 및 적용

1.  **데이터베이스에서 쿠키 조회**: `lambda_handler` 함수가 실행되면 가장 먼저 `session_get_db` 함수를 호출하여 데이터베이스에 저장된 쿠키가 있는지 확인합니다.

    ```python
    def lambda_handler(event, context):
        try:
            session_data = session_get_db()
            if not session_data:
                login(None) # 저장된 쿠키 없음 -> 최초 로그인
            else:
                print("쿠키 로그인 진행")
                print("쿠키:", json.loads(session_data))
                login(json.loads(session_data)) # 저장된 쿠키로 로그인
            # ...
    ```

2.  **쿠키를 드라이버에 추가**: `login` 함수는 데이터베이스에서 가져온 쿠키 목록(`json.loads(session_data)`)을 전달받습니다. 이 쿠키들을 `driver.add_cookie(cookie)`를 통해 현재 웹 드라이버 세션에 하나씩 추가합니다.

    ```python
    def login(cookies):
        # ...
        else: # 쿠키가 있을 경우
            for cookie in cookies:
                driver.add_cookie(cookie)
    ```

### 나. 쿠키 유효성 검증 및 갱신

1.  **로그인 상태 확인**: 쿠키를 드라이버에 추가한 후, 로그인이 필요한 페이지(예: `myInfoV2`)로 이동하여 현재 URL에 `login` 문자열이 포함되어 있는지 확인합니다. 만약 URL에 `login`이 포함되어 있다면, 이는 쿠키가 만료되었거나 유효하지 않다는 것을 의미합니다.

    ```python
    driver.get('https://nid.naver.com/user2/help/myInfoV2?lang=ko_KR')
    driver.implicitly_wait(10)

    print("쿠키 로그인 확인중")
    time.sleep(3)
    if "login" in driver.current_url:
        print("쿠키 로그인 실패, 쿠키 재발급 진행")
        login(None) # 쿠키가 유효하지 않으므로 최초 로그인부터 다시 시작
    ```

2.  **쿠키 갱신**: 만약 쿠키 로그인이 실패하면, `login(None)`을 재귀적으로 호출하여 아이디/비밀번호를 이용한 최초 로그인 절차를 다시 진행합니다. 이 과정이 성공적으로 완료되면 새로운 쿠키가 발급되어 데이터베이스에 갱신되므로, 다음 실행부터는 유효한 쿠키로 로그인을 시도할 수 있습니다.

## 3. 프로젝트 적용 (2025-09-26 수정 작업)

원본 소스(`lambda_function.py`)의 쿠키 처리 방식을 분석하여 우리 프로젝트의 `app/services/login_service.py`에 동일한 방식을 적용했습니다.

### 가. 주요 수정사항

1. **쿠키 검증 URL 변경**:
   - 기존: 임의의 보호된 페이지 사용
   - 수정: 원본과 동일한 `https://nid.naver.com/user2/help/myInfoV2?lang=ko_KR` 사용

2. **로그인 URL 수정**:
   - 기존: `https://nid.naver.com/nidlogin.login?mode=form&url=https://new.smartplace.naver.com/`
   - 수정: 원본과 동일한 `https://nid.naver.com/nidlogin.login?mode=form&url=https://www.naver.com/`

3. **대기 시간 조정**:
   - 쿠키 검증 시: `sleep(2.0)` → `sleep(3.0)` (원본과 동일)
   - 로그인 완료 후: 추가 안정화 대기 시간 `sleep(1.0)` 추가

4. **타임아웃 설정**:
   - URL 대기 타임아웃: `120_000ms` → `10000ms` (원본의 10초 설정)

5. **기본 동작 변경**:
   - `force_credential_login` 기본값: `True` → `False` (쿠키 우선 시도)

### 나. 세션 검증 로직 개선

**SmartPlace 세션 검증 수정**:
```python
# 기존: 특정 요소 대기
page.wait_for_selector('a:has-text("리뷰")', state="visible", timeout=15_000)

# 수정: 단순 대기로 변경 (쿠키 획득만 목적)
sleep(2.0)  # Wait for session to be established
```

이 수정으로 로그인 테스트 기능에서 UI 요소 의존성을 제거하고 쿠키 획득에만 집중하도록 개선했습니다.

### 다. 적용된 코드 구조

수정된 `login` 함수의 핵심 로직:

```python
def login(self, user_id: str, password: str, force_credential_login: bool = False) -> LoginResult:
    # 1) 쿠키 기반 세션 재사용 시도
    if not force_credential_login and self.storage_path.exists():
        # 원본과 동일한 검증 페이지 사용
        page.goto(NAVER_PROFILE_URL, wait_until="load")
        sleep(3.0)  # 원본과 동일한 대기 시간

        if "login" not in page.url:
            # 쿠키 유효함 - SmartPlace 세션 갱신
            self._ensure_smartplace_session(page)
            return LoginResult(True, True, "저장된 쿠키로 로그인되었습니다.")

    # 2) 신규 로그인 (원본과 동일한 방식)
    page.goto("https://nid.naver.com/nidlogin.login?mode=form&url=https://www.naver.com/")

    # JavaScript로 직접 값 설정 (원본 방식)
    page.evaluate(f"document.querySelector('input[id=\"id\"]').setAttribute('value', '{user_id}')")
    page.evaluate(f"document.querySelector('input[id=\"pw\"]').setAttribute('value', '{password}')")

    # 원본과 동일한 타임아웃 (10초)
    page.wait_for_url(re.compile(r".*naver\.com.*"), timeout=10000)
```

### 라. 결과 확인

수정 작업 완료 후:
- 쿠키 파일(`.auth/cookies.json`)에 유효한 네이버 세션 쿠키들이 정상 저장됨
- `NID_SES`, `NID_AUT`, `BUC` 등 주요 인증 쿠키 포함
- SmartPlace 도메인의 localStorage 정보도 함께 저장되어 완전한 세션 정보 보존

이로써 원본 소스와 동일한 방식으로 쿠키를 발급받고 재사용하는 시스템이 구축되었습니다.
